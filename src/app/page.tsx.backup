"use client";

import { SidebarNav } from "@/components/dashboard/SidebarNav";
import { OmzetModule } from "@/components/dashboard/OmzetModule";
import { ProductsModule } from "@/components/dashboard/ProductsModule";
import { TransactionsModule } from "@/components/dashboard/TransactionsModule";
import { ReportsModule } from "@/components/dashboard/ReportsModule";
import ReceiptGenerator from "@/components/receipt/ReceiptGenerator";
import showToast from "@/components/ui/Toast";
import { useConfirm } from "@/components/ui/ConfirmModal";
import type { ModuleKey, ModuleNavItem } from "./types/dashboard";
import type {
  Category,
  FlashMessage,
  Product,
  StockLog,
  Transaction,
  TransactionItem,
} from "@/types/pos";
import { useEffect, useMemo, useState } from "react";
import { useDashboardData } from "@/hooks/useDashboardData";
import { useCategories } from "@/hooks/useCategories";
import { useProducts, type CreateProductData, type UpdateProductData } from "@/hooks/useProducts";
import { useAPI } from "@/utils/config";
import { receiptService } from "@/services/receiptService";
import { currency as formatCurrency, formatDateTime } from "@/utils/formatHelpers";
const storageKeys = {
  categories: "poslynk-categories",
  products: "poslynk-products",
  transactions: "poslynk-transactions",
  stockLogs: "poslynk-stock-logs",
};


const moduleNavItems: ModuleNavItem[] = [
  {
    key: "omzet",
    label: "Omzet",
    description: "Ringkasan pendapatan & grafik mini",
    icon: (
      <svg
        className="h-4 w-4"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth={1.8}
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <path d="M4 19h16" />
        <path d="M4 13l4-4 4 3 6-7" />
        <circle cx="8" cy="9" r="0" />
      </svg>
    ),
  },
  {
    key: "produk",
    label: "Barang",
    description: "Katalog produk & kategori",
    icon: (
      <svg
        className="h-4 w-4"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth={1.6}
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <rect x="4" y="4" width="7" height="7" rx="1.5" />
        <rect x="13" y="4" width="7" height="7" rx="1.5" />
        <rect x="4" y="13" width="7" height="7" rx="1.5" />
        <rect x="13" y="13" width="7" height="7" rx="1.5" />
      </svg>
    ),
  },
  {
    key: "transaksi",
    label: "Transaksi",
    description: "Kasir realtime + stok otomatis",
    icon: (
      <svg
        className="h-4 w-4"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth={1.6}
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <rect x="3" y="5" width="18" height="14" rx="2" />
        <path d="M3 10h18" />
        <path d="M7 15h2" />
      </svg>
    ),
  },
  {
    key: "laporan",
    label: "Laporan",
    description: "Riwayat transaksi lengkap",
    icon: (
      <svg
        className="h-4 w-4"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth={1.6}
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <path d="M8 3h7l5 5v13a1 1 0 0 1-1 1H8a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z" />
        <path d="M15 3v5h5" />
        <path d="M10 13h6" />
        <path d="M10 17h4" />
      </svg>
    ),
  },
];


const shortDate = (value: string) =>
  new Date(value).toLocaleDateString("id-ID", {
    day: "2-digit",
    month: "short",
  });

const generateId = () => {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const readFromStorage = <T,>(key: string, fallback: T): T => {
  if (typeof window === "undefined") return fallback;
  try {
    const raw = window.localStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : fallback;
  } catch (error) {
    console.error("Failed to read storage", error);
    return fallback;
  }
};

const persistToStorage = (key: string, value: unknown) => {
  if (typeof window === "undefined") return;
  try {
    window.localStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    console.error("Failed to write storage", error);
  }
};
export default function Home() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [stockLogs, setStockLogs] = useState<StockLog[]>([]);
  const [isReady, setIsReady] = useState(false);

  // API Integration
  const { data: dashboardData, isLoading: dashboardLoading, error: dashboardError } = useDashboardData();
  const {
    categories: apiCategories,
    isLoading: categoriesLoading,
    error: categoriesError,
    createCategory: apiCreateCategory,
    updateCategory: apiUpdateCategory,
    deleteCategory: apiDeleteCategory,
    refetch: refetchCategories
  } = useCategories();
  const {
    products: apiProducts,
    isLoading: productsLoading,
    error: productsError,
    createProduct: apiCreateProduct,
    updateProduct: apiUpdateProduct,
    deleteProduct: apiDeleteProduct,
    refetch: refetchProducts
  } = useProducts();

  const shouldUseAPI = useAPI();
  const { confirmModal } = useConfirm();

  const [categoryForm, setCategoryForm] = useState({ name: "" });
  const [editingCategoryId, setEditingCategoryId] = useState<string | null>(null);

  const [productForm, setProductForm] = useState({
    name: "",
    price: "",
    categoryId: "",
    stock: "",
    photo: "",
  });
  const [editingProductId, setEditingProductId] = useState<string | null>(null);
  const [productFilter, setProductFilter] = useState("all");
  const [productSearch, setProductSearch] = useState("");

  const [cart, setCart] = useState<TransactionItem[]>([]);
  const [cash, setCash] = useState("0");
  const [transactionSearch, setTransactionSearch] = useState("");
  const [transactionCategoryFilter, setTransactionCategoryFilter] = useState("all");
  const [selectedTransactionId, setSelectedTransactionId] = useState<string | null>(null);
  const [dateRange, setDateRange] = useState({ start: "", end: "" });
  const [flash, setFlash] = useState<FlashMessage | null>(null);
  const [activeModule, setActiveModule] = useState<ModuleKey>("omzet");
  const [summaryModal, setSummaryModal] = useState<{
    show: boolean;
    transaction: Transaction | null;
  }>({ show: false, transaction: null });

  // Determine which data source to use
  const currentCategories = shouldUseAPI ? apiCategories : categories;
  const currentProducts = shouldUseAPI ? apiProducts : products;

  // Debug category data
  if (typeof window !== 'undefined') {
    console.log('Data Source Debug:', {
      shouldUseAPI,
      envVar: process.env.NEXT_PUBLIC_USE_API,
      apiCategoriesCount: apiCategories?.length || 0,
      localCategoriesCount: categories?.length || 0,
      apiProductsCount: apiProducts?.length || 0,
      localProductsCount: products?.length || 0,
      finalCategoriesCount: currentCategories?.length || 0,
      finalProductsCount: currentProducts?.length || 0,
      isReady,
      apiCategories: apiCategories,
      currentCategories: currentCategories,
      isLoading: categoriesLoading
    });
  }

  // Unified category management functions
  const handleCreateCategory = async (name: string) => {
    try {
      if (shouldUseAPI) {
        await apiCreateCategory(name);
        // Refetch categories to get the latest data from server
        await refetchCategories();
      } else {
        // Local storage implementation
        const newCategory: Category = {
          id: generateId(),
          name,
          createdAt: new Date().toISOString(),
        };
        setCategories(prev => [...prev, newCategory]);
      }
      showToast.categoryAdded(name);
    } catch (error: any) {
      showToast.error('Gagal menambahkan kategori', error.message);
    }
  };

  const handleUpdateCategory = async (id: string, name: string) => {
    try {
      if (shouldUseAPI) {
        await apiUpdateCategory(id, name);
        // Refetch categories to get the latest data from server
        await refetchCategories();
      } else {
        // Local storage implementation
        setCategories(prev => prev.map(cat =>
          cat.id === id ? { ...cat, name } : cat
        ));
      }
      showToast.categoryUpdated(name);
    } catch (error: any) {
      showToast.error('Gagal mengupdate kategori', error.message);
    }
  };

  const handleDeleteCategory = async (id: string) => {
    try {
      if (shouldUseAPI) {
        await apiDeleteCategory(id);
        // Refetch categories to get the latest data from server
        await refetchCategories();
      } else {
        // Local storage implementation
        setCategories(prev => prev.filter(cat => cat.id !== id));
      }
      showToast.categoryDeleted(currentCategories.find(cat => cat.id === id)?.name);
    } catch (error: any) {
      showToast.error('Gagal menghapus kategori', error.message);
    }
  };

  // Unified product management functions
  const handleCreateProduct = async (data: CreateProductData) => {
    try {
      if (shouldUseAPI) {
        await apiCreateProduct(data);
        // Refetch products to get the latest data from server
        await refetchProducts();
      } else {
        // Local storage implementation
        const newProduct: Product = {
          id: generateId(),
          name: data.name,
          price: data.price,
          stock: data.stock,
          photo: data.photo,
          categoryId: data.categoryId,
          createdAt: new Date().toISOString(),
        };
        setProducts(prev => [...prev, newProduct]);
      }
      showToast.productAdded(data.name);
    } catch (error: any) {
      showToast.error('Gagal menambahkan produk', error.message);
    }
  };

  const handleUpdateProduct = async (id: string, data: UpdateProductData) => {
    try {
      if (shouldUseAPI) {
        await apiUpdateProduct(id, data);
        // Refetch products to get the latest data from server
        await refetchProducts();
      } else {
        // Local storage implementation
        setProducts(prev => prev.map(product =>
          product.id === id
            ? {
                ...product,
                name: data.name,
                price: data.price,
                stock: data.stock,
                photo: data.photo,
                categoryId: data.categoryId,
                createdAt: new Date().toISOString(),
              }
            : product
        ));
      }
      showToast.productUpdated(data.name);
    } catch (error: any) {
      showToast.error('Gagal mengupdate produk', error.message);
    }
  };

  const handleDeleteProduct = async (id: string) => {
    try {
      // Get product name before deletion for toast
      const productToDelete = currentProducts.find(product => product.id === id);

      if (shouldUseAPI) {
        await apiDeleteProduct(id);
        // Refetch products to get the latest data from server
        await refetchProducts();
      } else {
        // Local storage implementation
        setProducts(prev => prev.filter(product => product.id !== id));
      }
      showToast.productDeleted(productToDelete?.name);
    } catch (error: any) {
      showToast.error('Gagal menghapus produk', error.message);
    }
  };
  useEffect(() => {
    if (typeof window === "undefined") return;

    // Only load from localStorage if NOT using API
    if (!shouldUseAPI) {
      const defaultCategories: Category[] = [
        { id: generateId(), name: "Umum", createdAt: new Date().toISOString() },
      ];

      // eslint-disable-next-line react-hooks/set-state-in-effect
      setCategories(readFromStorage<Category[]>(storageKeys.categories, defaultCategories));
      setProducts(readFromStorage<Product[]>(storageKeys.products, []));
      setTransactions(readFromStorage<Transaction[]>(storageKeys.transactions, []));
      setStockLogs(readFromStorage<StockLog[]>(storageKeys.stockLogs, []));
    }

    setIsReady(true);
  }, [shouldUseAPI]);

  useEffect(() => {
    if (!isReady) return;
    persistToStorage(storageKeys.categories, categories);
  }, [categories, isReady]);

  useEffect(() => {
    if (!isReady) return;
    persistToStorage(storageKeys.products, products);
  }, [products, isReady]);

  useEffect(() => {
    if (!isReady) return;
    persistToStorage(storageKeys.transactions, transactions);
  }, [transactions, isReady]);

  useEffect(() => {
    if (!isReady) return;
    persistToStorage(storageKeys.stockLogs, stockLogs);
  }, [stockLogs, isReady]);

  useEffect(() => {
    if (!categories.length) return;
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProductForm((prev) => {
      if (prev.categoryId) return prev;
      return { ...prev, categoryId: categories[0].id };
    });
  }, [categories]);

  useEffect(() => {
    if (!flash) return;
    const timeout = window.setTimeout(() => setFlash(null), 4000);
    return () => window.clearTimeout(timeout);
  }, [flash]);
  const triggerFlash = (type: FlashMessage["type"], text: string) => {
    setFlash({ type, text });
  };

  const filteredProducts = useMemo(() => {
    // Ensure currentProducts is an array before filtering
    if (!Array.isArray(currentProducts)) {
      console.log('[page.tsx Filtering] currentProducts is not array:', currentProducts);
      return [];
    }

    console.log('[page.tsx Filtering] Starting filter with:', {
      currentProductsCount: currentProducts.length,
      currentProductsSample: currentProducts.slice(0, 2),
      productFilter,
      productSearch,
      shouldUseAPI
    });

    const filtered = currentProducts.filter((product) => {
      // Handle empty categoryId - if product has no category, only show in "all" filter
      const productCategoryId = product.categoryId || "";
      const matchCategory = productFilter === "all" || productCategoryId === productFilter;
      const matchSearch = productSearch === "" || product.name.toLowerCase().includes(productSearch.toLowerCase());

      console.log(`[page.tsx Filtering] Product "${product.name}":`, {
        originalCategoryId: product.categoryId,
        normalizedCategoryId: productCategoryId,
        productFilter,
        matchCategory,
        productSearch,
        matchSearch,
        passesFilter: matchCategory && matchSearch
      });

      return matchCategory && matchSearch;
    });

    console.log('[page.tsx Filtering] Result:', {
      totalProducts: currentProducts.length,
      filteredCount: filtered.length,
      filteredProductsSample: filtered.slice(0, 2)
    });

    return filtered;
  }, [currentProducts, productFilter, productSearch, shouldUseAPI]);

  const matchingProducts = useMemo(() => {
    if (!Array.isArray(currentProducts)) return [];

    console.log('[page.tsx Transaction Filtering] Starting with:', {
      currentProductsCount: currentProducts.length,
      transactionSearch,
      transactionCategoryFilter,
      sampleProducts: currentProducts.slice(0, 2)
    });

    // CRITICAL FIX: Ensure strict category comparison
    const filtered = currentProducts
      .filter((product) => {
        const productCategoryId = product.categoryId || "";
        const matchName = transactionSearch === "" || product.name.toLowerCase().includes(transactionSearch.toLowerCase());

        // Strict category matching
        const matchCategory =
          transactionCategoryFilter === "all" ||
          productCategoryId === transactionCategoryFilter;

        console.log(`[page.tsx Transaction Filtering] Product "${product.name}":`, {
          originalCategoryId: product.categoryId,
          normalizedCategoryId: productCategoryId,
          transactionCategoryFilter,
          matchName,
          matchCategory,
          passesFilter: matchName && matchCategory,
          shouldShow: matchName && matchCategory // Expected display result
        });

        // CRITICAL FIX: Return EXACT match, not passesFilter
        return matchName && matchCategory;
      });

    console.log('[page.tsx Transaction Filtering] Final Filtered Array:', filtered);

    return filtered.slice(0, 6);
  }, [currentProducts, transactionSearch, transactionCategoryFilter, categories]);

  const cartSubtotal = useMemo(
    () => cart.reduce((sum, item) => sum + item.price * item.qty, 0),
    [cart],
  );

  const change = Number(cash || "0") - cartSubtotal;

  const today = new Date();
  const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const todayTransactions = transactions.filter((trx) => new Date(trx.createdAt) >= startOfDay);
  const todayRevenue = todayTransactions.reduce((sum, trx) => sum + trx.total, 0);

  const topProduct = useMemo(() => {
    const soldMap = new Map<string, { name: string; qty: number }>();
    transactions.forEach((trx) => {
      trx.items.forEach((item) => {
        const current = soldMap.get(item.productId);
        if (current) {
          current.qty += item.qty;
          soldMap.set(item.productId, current);
        } else {
          soldMap.set(item.productId, { name: item.name, qty: item.qty });
        }
      });
    });
    let best: { name: string; qty: number } | null = null;
    for (const value of soldMap.values()) {
      if (!best || value.qty > best.qty) {
        best = value;
      }
    }
    return best?.name ?? "-";
  }, [transactions]);

  const weeklyTrend = useMemo(() => {
    const trend: { label: string; total: number }[] = [];
    const base = new Date();
    for (let i = 6; i >= 0; i -= 1) {
      const target = new Date(base);
      target.setDate(base.getDate() - i);
      const start = new Date(target.getFullYear(), target.getMonth(), target.getDate());
      const end = new Date(start);
      end.setDate(start.getDate() + 1);
      const total = transactions
        .filter((trx) => {
          const date = new Date(trx.createdAt);
          return date >= start && date < end;
        })
        .reduce((sum, trx) => sum + trx.total, 0);
      trend.push({ label: start.toLocaleDateString("id-ID", { weekday: "short" }), total });
    }
    return trend;
  }, [transactions]);

  const filteredTransactions = useMemo(() => {
    return transactions.filter((trx) => {
      if (!dateRange.start && !dateRange.end) return true;
      const trxDate = new Date(trx.createdAt).setHours(0, 0, 0, 0);
      const startDate = dateRange.start ? new Date(dateRange.start).setHours(0, 0, 0, 0) : -Infinity;
      const endDate = dateRange.end ? new Date(dateRange.end).setHours(0, 0, 0, 0) : Infinity;
      return trxDate >= startDate && trxDate <= endDate;
    });
  }, [transactions, dateRange]);

  const selectedTransaction = useMemo(
    () => transactions.find((trx) => trx.id === selectedTransactionId) ?? null,
    [transactions, selectedTransactionId],
  );

  const latestTransactions = useMemo(() => transactions.slice(0, 5), [transactions]);
  const totalRevenue = useMemo(() => transactions.reduce((sum, trx) => sum + trx.total, 0), [transactions]);
  const averageOrder = transactions.length ? totalRevenue / transactions.length : 0;
  const maxWeeklyTotal = Math.max(1, ...weeklyTrend.map((point) => point.total));
  const resetProductForm = () => {
    setProductForm({ name: "", price: "", categoryId: categories[0]?.id ?? "", stock: "", photo: "" });
    setEditingProductId(null);
  };

  const resetCategoryForm = () => {
    setCategoryForm({ name: "" });
    setEditingCategoryId(null);
  };

  const upsertCategory = () => {
    if (!categoryForm.name.trim()) {
      triggerFlash("error", "Nama kategori wajib diisi");
      return;
    }
    if (editingCategoryId) {
      setCategories((prev) =>
        prev.map((category) =>
          category.id === editingCategoryId ? { ...category, name: categoryForm.name.trim() } : category,
        ),
      );
      triggerFlash("success", "Kategori diperbarui");
    } else {
      const exists = currentCategories.some(
        (category) => category.name.toLowerCase() === categoryForm.name.toLowerCase(),
      );
      if (exists) {
        triggerFlash("info", "Kategori sudah tersedia");
        return;
      }
      setCategories((prev) => [
        ...prev,
        { id: generateId(), name: categoryForm.name.trim(), createdAt: new Date().toISOString() },
      ]);
      triggerFlash("success", "Kategori ditambahkan");
    }
    resetCategoryForm();
  };

  
  
  const upsertProduct = () => {
    if (!productForm.name.trim()) {
      triggerFlash("error", "Nama produk wajib diisi");
      return;
    }
    const priceValue = Number(productForm.price);
    const stockValue = Number(productForm.stock || "0");
    if (Number.isNaN(priceValue) || priceValue <= 0) {
      triggerFlash("error", "Harga tidak valid");
      return;
    }
    if (stockValue < 0) {
      triggerFlash("error", "Stok tidak boleh negatif");
      return;
    }
    if (!productForm.categoryId) {
      triggerFlash("error", "Pilih kategori");
      return;
    }
    if (editingProductId) {
      setProducts((prev) =>
        prev.map((product) =>
          product.id === editingProductId
            ? {
                ...product,
                name: productForm.name.trim(),
                price: priceValue,
                categoryId: productForm.categoryId,
                stock: stockValue,
                photo: productForm.photo.trim(),
              }
            : product,
        ),
      );
      showToast.productUpdated(productForm.name.trim());
    } else {
      setProducts((prev) => [
        ...prev,
        {
          id: generateId(),
          name: productForm.name.trim(),
          price: priceValue,
          categoryId: productForm.categoryId,
          stock: stockValue,
          photo: productForm.photo.trim(),
          createdAt: new Date().toISOString(),
        },
      ]);
      triggerFlash("success", "Produk ditambahkan");
    }
    resetProductForm();
  };

  
    const handleAddToCart = (productId: string) => {
    const product = currentProducts.find((item) => item.id === productId);
    if (!product) {
      showToast.error("Produk tidak ditemukan");
      return;
    }
    if (product.stock <= 0) {
      showToast.info("Stok produk kosong");
      return;
    }
    setCart((prev) => {
      const existing = prev.find((item) => item.productId === product.id);
      if (existing) {
        if (existing.qty >= product.stock) {
          showToast.info("Stok tidak mencukupi");
          return prev;
        }
        return prev.map((item) =>
          item.productId === product.id ? { ...item, qty: item.qty + 1 } : item,
        );
      }
      return [...prev, { productId: product.id, name: product.name, price: product.price, qty: 1 }];
    });
    setTransactionSearch("");
  };

  const updateCartQty = (productId: string, qty: number) => {
    if (qty <= 0) {
      removeCartItem(productId);
      return;
    }

    const product = currentProducts.find((item) => item.id === productId);
    if (!product) {
      triggerFlash("error", "Produk tidak ditemukan");
      return;
    }

    if (qty > product.stock) {
      triggerFlash("info", "Stok tidak mencukupi");
      return;
    }

    setCart((prev) =>
      prev.map((item) =>
        item.productId === productId ? { ...item, qty } : item,
      )
    );
  };

  const removeCartItem = (productId: string) => {
    setCart((prev) => prev.filter((item) => item.productId !== productId));
  };

    const handleSaveTransaction = () => {
    if (!cart.length) {
      triggerFlash("info", "Keranjang kosong");
      return;
    }
    const paidValue = Number(cash);
    if (Number.isNaN(paidValue) || paidValue < cartSubtotal) {
      triggerFlash("error", "Tunai belum mencukupi");
      return;
    }

    const now = new Date().toISOString();
    const newTransaction: Transaction = {
      id: `TRX-${now.replace(/\D/g, "").slice(-8)}`,
      createdAt: now,
      items: cart,
      subtotal: cartSubtotal,
      total: cartSubtotal,
      paid: paidValue,
      change: paidValue - cartSubtotal,
    };

    // Show summary modal instead of directly saving
    setSummaryModal({ show: true, transaction: newTransaction });
  };

  const confirmSaveTransaction = () => {
    if (!summaryModal.transaction) return;

    const newTransaction = summaryModal.transaction;

    // Save transaction
    setTransactions((prev) => [newTransaction, ...prev]);

    // Update product stock
    setProducts((prev) =>
      prev.map((product) => {
        const cartItem = cart.find((item) => item.productId === product.id);
        if (!cartItem) return product;
        return { ...product, stock: Math.max(product.stock - cartItem.qty, 0) };
      }),
    );

    // Create stock logs
    const logs = cart.map((item) => ({
      id: generateId(),
      productId: item.productId,
      type: "out" as const,
      amount: item.qty,
      note: `Penjualan ${newTransaction.id}`,
      createdAt: newTransaction.createdAt,
    }));
    setStockLogs((prev) => [...logs, ...prev]);

    // Clear cart and form
    setCart([]);
    setCash("0");
    setTransactionSearch("");
    setSelectedTransactionId(newTransaction.id);

    // Close modal
    setSummaryModal({ show: false, transaction: null });

    // Generate PDF after successful save
    handleGenerateReceipt(newTransaction);
    triggerFlash("success", "Transaksi tersimpan");
  };

  const cancelSaveTransaction = () => {
    setSummaryModal({ show: false, transaction: null });
  };

    const pageWidth = doc.internal.pageSize.getWidth();
    const centerX = pageWidth / 2;
    let cursorY = 10;

    // Store Header
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text("Sentosa POS", centerX, cursorY, { align: 'center' });
    cursorY += 8;

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.text('Jl. Contoh No. 123, Jakarta', centerX, cursorY, { align: 'center' });
    cursorY += 5;
    doc.text('Tel: (021) 1234567', centerX, cursorY, { align: 'center' });
    cursorY += 8;

    // Separator line
    doc.setLineWidth(0.2);
    doc.line(5, cursorY, pageWidth - 5, cursorY);
    cursorY += 6;

    // Transaction Info
    doc.setFontSize(9);
    doc.text(`ID: ${transaction.id}`, 5, cursorY);
    cursorY += 5;
    doc.text(`Kasir: Admin`, 5, cursorY);
    cursorY += 5;
    const date = new Date(transaction.createdAt);
    doc.text(date.toLocaleString('id-ID', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }), 5, cursorY);
    cursorY += 8;

    // Items Header
    doc.setFont('helvetica', 'bold');
    doc.text('Item', 5, cursorY);
    doc.text('Qty', pageWidth - 25, cursorY, { align: 'right' });
    doc.text('Total', pageWidth - 5, cursorY, { align: 'right' });
    cursorY += 6;
    doc.setFont('helvetica', 'normal');

    // Transaction Items
    transaction.items.forEach((item) => {
      // Item name (truncate if too long)
      const itemName = item.name.length > 15 ? item.name.substring(0, 15) + '...' : item.name;
      doc.text(itemName, 5, cursorY);

      // Quantity and unit price
      doc.text(`${item.qty}x${currency(item.price)}`, pageWidth - 25, cursorY, { align: 'right' });

      // Item total
      doc.text(currency(item.price * item.qty), pageWidth - 5, cursorY, { align: 'right' });
      cursorY += 6;
    });

    cursorY += 4;

    // Separator line
    doc.setLineWidth(0.2);
    doc.line(5, cursorY, pageWidth - 5, cursorY);
    cursorY += 6;

    // Summary
    doc.setFontSize(9);
    doc.text('Subtotal:', 5, cursorY);
    doc.text(currency(transaction.subtotal), pageWidth - 5, cursorY, { align: 'right' });
    cursorY += 5;

    doc.text('Total:', 5, cursorY);
    doc.text(currency(transaction.total), pageWidth - 5, cursorY, { align: 'right' });
    cursorY += 5;

    doc.text('Tunai:', 5, cursorY);
    doc.text(currency(transaction.paid), pageWidth - 5, cursorY, { align: 'right' });
    cursorY += 5;

    doc.setFont('helvetica', 'bold');
    doc.text('Kembali:', 5, cursorY);
    doc.text(currency(transaction.change), pageWidth - 5, cursorY, { align: 'right' });
    cursorY += 8;
    doc.setFont('helvetica', 'normal');

    // Footer separator
    doc.setLineWidth(0.2);
    doc.line(5, cursorY, pageWidth - 5, cursorY);
    cursorY += 6;

    // Footer text
    doc.setFontSize(8);
    doc.text('Terima kasih atas kunjungan Anda', centerX, cursorY, { align: 'center' });
    cursorY += 5;
    doc.text('Barang yang sudah dibeli', centerX, cursorY, { align: 'center' });
    cursorY += 5;
    doc.text('tidak dapat dikembalikan', centerX, cursorY, { align: 'center' });
    cursorY += 8;

    // doc.text('** PILIHAN PEMBAYARAN **', centerX, cursorY, { align: 'center' });
    // cursorY += 5;
    // doc.text('Cash, QRIS, E-Wallet', centerX, cursorY, { align: 'center' });
    // cursorY += 10;

    // // QR Code placeholder (text representation)
    // doc.setLineWidth(0.1);
    // const qrSize = 20;
    // const qrX = (pageWidth - qrSize) / 2;
    // doc.rect(qrX, cursorY, qrSize, qrSize);

    // // Simple QR pattern (dotted)
    // for (let i = 0; i < 5; i++) {
    //   for (let j = 0; j < 5; j++) {
    //     if ((i + j) % 2 === 0) {
    //       doc.circle(qrX + 4 + i * 4, cursorY + 4 + j * 4, 1.5, 'F');
    //     }
    //   }
    // }

    // cursorY += qrSize + 5;

    // doc.setFontSize(6);
    doc.text('Scan untuk info lebih lanjut', centerX, cursorY, { align: 'center' });
    cursorY += 10;

    // // Additional space for clean tear
    // cursorY += 10;
    doc.setLineWidth(0.1);
    // Simple solid line instead of dashed for compatibility
    doc.line(5, cursorY, pageWidth - 5, cursorY);

    // Save with automatic download
    doc.save(`struk-${transaction.id}.pdf`);

    // Auto-print feature (controlled by configuration)
    if (RECEIPT_SETTINGS.autoPrint && typeof window !== 'undefined' && window.print) {
      setTimeout(() => {
        // Create blob and open for printing
        const pdfBlob = doc.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);
        const printWindow = window.open(pdfUrl);

        if (printWindow) {
          printWindow.onload = () => {
            printWindow.print();
            setTimeout(() => {
              printWindow.close();
              URL.revokeObjectURL(pdfUrl);
            }, 1000);
          };
        }
      }, 500);
    }

    // Show notification about auto-print status
    if (true) {
      console.log(`📄 PDF struk-${transaction.id} telah dibuat`);
      if (RECEIPT_SETTINGS.autoPrint) {
        console.log('🖨️ Auto-print diaktifkan - Dialog print akan otomatis terbuka');
      } else {
        console.log('💡 Auto-print dinonaktifkan - Untuk mengaktifkan, ubah AUTO_PRINT_RECEIPT menjadi true di baris 37');
        console.log('📋 Atau cetak manual dari file PDF yang telah di-download');
      }
    }
  };

  const handleShareWhatsApp = (transaction: Transaction) => {
    const lines = [
      `Struk Sentosa POS`,
      `ID: ${transaction.id}`,
      `Tanggal: ${formatDateTime(transaction.createdAt)}`,
      "",
    ];
    transaction.items.forEach((item) =>
      lines.push(`${item.name} x${item.qty} = ${currency(item.price * item.qty)}`),
    );
    lines.push("", `Total: ${currency(transaction.total)}`, `Tunai: ${currency(transaction.paid)}`);
    lines.push(`Kembalian: ${currency(transaction.change)}`);
    const url = `https://wa.me/?text=${encodeURIComponent(lines.join("\n"))}`;
    window.open(url, "_blank");
  };
  const quickFilter = (type: "today" | "week" | "month" | "all") => {
    const now = new Date();
    if (type === "all") {
      setDateRange({ start: "", end: "" });
      return;
    }
    if (type === "today") {
      const date = now.toISOString().split("T")[0];
      setDateRange({ start: date, end: date });
      return;
    }
    if (type === "week") {
      const end = now.toISOString().split("T")[0];
      const startDate = new Date(now);
      startDate.setDate(now.getDate() - 6);
      setDateRange({ start: startDate.toISOString().split("T")[0], end });
      return;
    }
    if (type === "month") {
      const start = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split("T")[0];
      const end = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split("T")[0];
      setDateRange({ start, end });
    }
  };

  const productNameById = (id: string) => currentProducts.find((item) => item.id === id)?.name ?? "-";
  const activeNav = moduleNavItems.find((item) => item.key === activeModule);

  return (
    <div className="min-h-screen py-12 text-[var(--foreground)]">
      <div className="mx-auto flex w-full max-w-7xl flex-col gap-8 px-4 lg:flex-row">
        <SidebarNav
          storeName={storeName}
          summaryText="Kelola transaksi, produk, laporan, dan omzet dari satu layar."
          totalRevenueFormatted={currency(totalRevenue)}
          items={moduleNavItems}
          activeModule={activeModule}
          onSelect={setActiveModule}
        />
        <main className="flex-1 space-y-6">
          <header className="rounded-3xl border border-[var(--card-border)] bg-white/80 px-6 py-5 shadow-sm shadow-[#5e8c520f]">
            <p className="text-xs font-semibold uppercase tracking-[0.3em] text-[var(--color-primary)]">Modul aktif</p>
            <h2 className="mt-1 text-3xl font-bold text-[var(--foreground)]">{activeNav?.label ?? "Omzet"}</h2>
            <p className="text-sm text-[var(--text-muted)]">{activeNav?.description}</p>
          </header>

          {flash && (
            <div
              className={`rounded-2xl border px-4 py-3 text-sm shadow-sm transition ${
                flash.type === "error"
                  ? "border-red-200 bg-red-50 text-red-700"
                  : flash.type === "success"
                    ? "border-[#5e8c5233] bg-[#a1b98633] text-[#2f4a28]"
                    : "border-[#a1b98633] bg-white/70 text-[var(--text-muted)]"
              }`}
            >
              {flash.text}
            </div>
          )}

          {activeModule === "omzet" && (
            <OmzetModule
              todayTransactionsCount={shouldUseAPI && dashboardData ? dashboardData.todayTransactionsCount : todayTransactions.length}
              todayRevenue={shouldUseAPI && dashboardData ? dashboardData.todayRevenue : todayRevenue}
              topProduct={shouldUseAPI && dashboardData ? dashboardData.topProduct : topProduct}
              weeklyTrend={shouldUseAPI && dashboardData ? dashboardData.weeklyTrend : weeklyTrend}
              maxWeeklyTotal={shouldUseAPI && dashboardData ? dashboardData.maxWeeklyTotal : maxWeeklyTotal}
              latestTransactions={shouldUseAPI && dashboardData ? dashboardData.latestTransactions : latestTransactions}
              totalRevenue={shouldUseAPI && dashboardData ? dashboardData.totalRevenue : totalRevenue}
              averageOrder={shouldUseAPI && dashboardData ? dashboardData.averageOrder : averageOrder}
              totalTransactions={shouldUseAPI && dashboardData ? dashboardData.totalTransactions : transactions.length}
              currency={currency}
              formatDateTime={formatDateTime}
              isLoading={shouldUseAPI && dashboardLoading}
              error={shouldUseAPI ? dashboardError : undefined}
            />
          )}

          {activeModule === "produk" && (
            <ProductsModule
              categories={currentCategories}
              filteredProducts={filteredProducts}
              productFilter={productFilter}
              productSearch={productSearch}
              productForm={productForm}
              editingProductId={editingProductId}
              categoryForm={categoryForm}
              editingCategoryId={editingCategoryId}
              isLoading={shouldUseAPI && (categoriesLoading || productsLoading)}
              error={shouldUseAPI ? (categoriesError || productsError) : undefined}
              setProductFilter={setProductFilter}
              setProductSearch={setProductSearch}
              setProductForm={setProductForm}
              setCategoryForm={setCategoryForm}
              resetProductForm={resetProductForm}
              resetCategoryForm={resetCategoryForm}
              upsertProduct={() => {
                const productData: CreateProductData = {
                  name: productForm.name,
                  price: parseInt(productForm.price) || 0,
                  stock: parseInt(productForm.stock) || 0,
                  categoryId: productForm.categoryId,
                  photo: productForm.photo || undefined,
                };

                if (editingProductId) {
                  handleUpdateProduct(editingProductId, productData);
                } else {
                  handleCreateProduct(productData);
                }
                resetProductForm();
                setEditingProductId(null);
              }}
              handleEditProduct={(id) => {
                const product = currentProducts.find(p => p.id === id);
                if (product) {
                  setProductForm({
                    name: product.name,
                    price: product.price.toString(),
                    categoryId: product.categoryId,
                    stock: product.stock.toString(),
                    photo: product.photo || '',
                  });
                  setEditingProductId(id);
                }
              }}
              handleDeleteProduct={async (id) => {
                const product = currentProducts.find(p => p.id === id);
                const confirmed = await confirmModal({
                  title: 'Hapus Produk',
                  message: 'Apakah Anda yakin ingin menghapus produk ini?',
                  confirmText: 'Ya, Hapus',
                  cancelText: 'Batal',
                  type: 'danger',
                  itemName: product?.name,
                });
                if (confirmed) {
                  handleDeleteProduct(id);
                }
              }}
              upsertCategory={() => {
                const name = categoryForm.name.trim();
                if (!name) return;

                if (editingCategoryId) {
                  handleUpdateCategory(editingCategoryId, name);
                } else {
                  handleCreateCategory(name);
                }
                resetCategoryForm();
                setEditingCategoryId(null);
              }}
              handleEditCategory={(id) => {
                const category = currentCategories.find(c => c.id === id);
                if (category) {
                  setCategoryForm({ name: category.name });
                  setEditingCategoryId(id);
                }
              }}
              handleDeleteCategory={async (id) => {
                const category = currentCategories.find(c => c.id === id);
                const confirmed = await confirmModal({
                  title: 'Hapus Kategori',
                  message: 'Apakah Anda yakin ingin menghapus kategori ini?',
                  confirmText: 'Ya, Hapus',
                  cancelText: 'Batal',
                  type: 'danger',
                  itemName: category?.name,
                });
                if (confirmed) {
                  handleDeleteCategory(id);
                }
              }}
              currency={currency}
            />
          )}

          {activeModule === "transaksi" && (
            <TransactionsModule
              categories={currentCategories}
              transactionSearch={transactionSearch}
              setTransactionSearch={setTransactionSearch}
              matchingProducts={matchingProducts}
              handleAddToCart={handleAddToCart}
              cart={cart}
              products={currentProducts}
              updateCartQty={updateCartQty}
              removeCartItem={removeCartItem}
              cartSubtotal={cartSubtotal}
              cash={cash}
              setCash={setCash}
              change={change}
              handleSaveTransaction={handleSaveTransaction}
              stockLogs={stockLogs}
              productNameById={productNameById}
              formatDateTime={formatDateTime}
              selectedTransaction={selectedTransaction}
              handleGenerateReceipt={receiptService.generateReceipt}
              handleShareWhatsApp={receiptService.shareWhatsApp}
              currency={formatCurrency}
              transactionCategoryFilter={transactionCategoryFilter}
              setTransactionCategoryFilter={setTransactionCategoryFilter}
            />
          )}

          {activeModule === "laporan" && (
            <ReportsModule
              filteredTransactions={filteredTransactions}
              dateRange={dateRange}
              setDateRange={setDateRange}
              quickFilter={quickFilter}
              shortDate={shortDate}
              currency={currency}
              setSelectedTransactionId={setSelectedTransactionId}
            />
          )}
        </main>
      </div>

      {/* Summary Transaction Modal */}
      {summaryModal.show && summaryModal.transaction && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto">
            <h3 className="text-xl font-semibold mb-4 text-gray-900">Konfirmasi Transaksi</h3>

            <div className="space-y-3 mb-6">
              <div>
                <p className="text-sm text-gray-600">ID Transaksi</p>
                <p className="font-medium">{summaryModal.transaction.id}</p>
              </div>
              <div>
                <p className="text-sm text-gray-600">Tanggal</p>
                <p className="font-medium">{formatDateTime(summaryModal.transaction.createdAt)}</p>
              </div>

              <div className="border-t pt-3">
                <h4 className="font-medium mb-2">Detail Produk:</h4>
                <div className="space-y-2">
                  {summaryModal.transaction.items.map((item) => (
                    <div key={item.productId} className="flex justify-between text-sm">
                      <span>
                        {item.name} x{item.qty}
                      </span>
                      <span className="font-medium">{currency(item.price * item.qty)}</span>
                    </div>
                  ))}
                </div>
              </div>

              <div className="border-t pt-3 space-y-2">
                <div className="flex justify-between">
                  <span>Subtotal</span>
                  <span>{currency(summaryModal.transaction.subtotal)}</span>
                </div>
                <div className="flex justify-between">
                  <span>Tunai</span>
                  <span>{currency(summaryModal.transaction.paid)}</span>
                </div>
                <div className="flex justify-between font-semibold text-lg border-t pt-2">
                  <span>Kembalian</span>
                  <span className={summaryModal.transaction.change >= 0 ? "text-green-600" : "text-red-600"}>
                    {currency(summaryModal.transaction.change)}
                  </span>
                </div>
              </div>
            </div>

            <div className="flex gap-3">
              <button
                type="button"
                className="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
                onClick={cancelSaveTransaction}
              >
                Batal
              </button>
              <button
                type="button"
                className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                onClick={confirmSaveTransaction}
              >
                Simpan & Cetak
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}



